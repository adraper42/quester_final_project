import random
from character_creation import Character
from items_and_actions import *

class Environment:
    """A scene that the player can interact with. Makes up the larger maps. May contain Items/Enemies.
    Parent class can only be instantiated by a sub class, passing itself (class) as an argument for the parent constructor.
    It is not finished initializing until the map that created it finishes being created and passes itself to the add_map method.
    Stores a dictionary of possible choices a player could make and the proper function to run the result."""

    enemy_choices = Enemy.__subclasses__()
    item_choices = Item.__subclasses__()

    def __init__(self,environment_type):
        """Creates a randomly generated Environment object, only to be used as a constructor for any sub class.
        Purely Environment objects cannot exist because it requires a subclass as argument that it takes certain info from.
        Initialization is not finished with this method, add_map(map) must be called when there is a finished map."""

        self.player = None
        self.description = random.choice(environment_type.description_choices)
        self.text = self.description[0]
        self.map_object = None       # |
        self.north = None     # |
        self.east = None      # |
        self.south = None     # |
        self.west = None      # |
        self.connections = [] # v fixed in add_map method

        # May or may not have Items/Enemies, generated by chance
        self.enemies = []
        if random.randint(1,10) == 10:
            creature_type = random.choice(environment_type.env_enemy_choices)
            for _ in range(random.randint(1,3)):
                self.enemies.append(creature_type(self))

        self.items = []
        for _ in range(random.choices([0,1,2],weights=[6,3,1])[0]):
            item = random.choice(environment_type.env_item_choices) # there cannot be two of the same item
                                                                    # bc of the name of the item being used as a key in a dict (actions)
            while len(self.items) > 0: # basically an if statement then a while True ;
                                       # only loops when there are already items in self.items,
                                       # only breaks at break
                if item in [type(x) for x in self.items]:
                    item = random.choice(environment_type.env_item_choices)
                else:
                    break
            self.items.append(item(self))
        
        # Changes self.text to reflect any items/enemies
        if self.enemies:
            if len(self.enemies) > 1:
                exist_enemies_phrase = f"are {len(self.enemies)} {self.enemies[0].creature}s"
            else:
                exist_enemies_phrase = f"is one {self.enemies[0].creature}"
            self.text += f" There {exist_enemies_phrase} in the space with you."
        if self.items:
            if len(self.items) > 1:
                exist_items_phrase = "is a "
                for i in range(len(self.items)):
                    exist_items_phrase += f"{self.items[i].name.lower()} and a "
                exist_items_phrase = exist_items_phrase[0:-7]
            else:
                exist_items_phrase = f"is a {self.items[0].name.lower()}"
            self.text += f" There {exist_items_phrase} in the space with you."

        # Generates actions based on items/enemies
        self.actions = {}
        self.actions = {"north":self.move_player_north,"east":self.move_player_east,"south":self.move_player_south,"west":self.move_player_west,"inspect":self.inspect}
        if self.enemies:
            self.actions["fight"] = self.battle
            self.actions["initiate"] = self.battle
            self.actions["attack"] = self.battle
            self.actions["battle"] = self.battle
            for enemy in self.enemies:
                self.actions[self.enemies[0].creature.lower()] = self.battle
        if self.items:
            self.actions["grab"] = lambda g = None : print("You must specify which item you want to grab.")#lol
            self.actions["take"] = lambda g = None : print("You must specify which item you want to take.")#i figured a lambda would work
                                                                                                           #since you can't store a call to print without it automatically printing
                                                                                                           #and it did haha
            for item in self.items:
                self.actions[item.name.lower()] = item.add_to_inventory
                self.actions["grab " + item.name.lower()] = item.add_to_inventory
                self.actions["grab the " + item.name.lower()] = item.add_to_inventory
                self.actions["take " + item.name.lower()] = item.add_to_inventory
                self.actions["take the " + item.name.lower()] = item.add_to_inventory
    
    def print(self):
        """Prints the description of the scene based on information randomly generated at instantiation"""
        print(self.text)

    def inspect(self):
        """Same as .print() but may reveal hidden information"""
        print(self.text)
        if self.description[1]:
            print(self.description[1])

    def get_north(self):
        """Returns the Environment object to the north of the current one in the map"""
        return self.map_object.get_north(self)
    
    def get_east(self):
        """Returns the Environment object to the east of the current one in the map"""
        return self.map_object.get_east(self)
    
    def get_south(self):
        """Returns the Environment object to the south of the current one in the map"""
        return self.map_object.get_south(self)
    
    def get_west(self):
        """Returns the Environment object to the west of the current one in the map"""
        return self.map_object.get_west(self)
    
    def add_map(self,map):
        """Finishes instantiation by taking a map and storing it and its associated relevant values"""
        self.map_object = map
        if self.get_north():
            self.north = self.get_north()
            self.connections.append(self.north)
        else:
            self.actions["north"] = lambda g = None : print(random.choice(["There is no land in that direction, only the edge of the sea.","You have reached the edge of the sea. You cannot go any further in this direction."]))
            # These lines all delete the option to go in a certain direction
            # if there is no Environment to go to in that direction
            # The map can only be so big

        if self.get_east():
            self.east = self.get_east()
            self.connections.append(self.east)
        else:
            self.actions["east"] = lambda g = None : print(random.choice(["There is no land in that direction, only the edge of the sea.","You have reached the edge of the sea. You cannot go any further in this direction."]))
        
        if self.get_south():
            self.south = self.get_south()
            self.connections.append(self.south)
        else:
            self.actions["south"] = lambda g = None : print(random.choice(["There is no land in that direction, only the edge of the sea.","You have reached the edge of the sea. You cannot go any further in this direction."]))
        
        if self.get_west():
            self.west = self.get_west()
            self.connections.append(self.west)
        else:
            self.actions["west"] = lambda g = None : print(random.choice(["There is no land in that direction, only the edge of the sea.","You have reached the edge of the sea. You cannot go any further in this direction."]))

        self.actions["map"] = self.map_object.debug##########TODO map is a debug feature and should be removed eventually!!!! or even better improved upon!!!!

    def remove_player(self):
        """Part of moving a player from one Environment ot the next.
        Removes a Player from the Environment and returns the player."""
        player_ = self.player
        self.player = None
        return player_

    def add_player(self,player_to_add):
        """Part of moving a player from one Environment ot the next.
        Takes a Player and adds it to the environment."""
        self.player = player_to_add

    def move_player_north(self):
        """Calls the map method to move the Player to the Environment to the north of this one."""
        self.map_object.move_player(self.north)

    def move_player_east(self):
        """Calls the map method to move the Player to the Environment to the east of this one."""
        self.map_object.move_player(self.east)

    def move_player_south(self):
        """Calls the map method to move the Player to the Environment to the south of this one."""
        self.map_object.move_player(self.south)

    def move_player_west(self):
        """Calls the map method to move the Player to the Environment to the west of this one."""
        self.map_object.move_player(self.west)
    
    def remove_item(self,item_to_remove):
        self.items.remove(item_to_remove)
        self.actions[item_to_remove.name.lower()] = "That doesn't seem to be here anymore."
        self.actions["grab " + item_to_remove.name.lower()] = "That doesn't seem to be here anymore."
        self.actions["grab the " + item_to_remove.name.lower()] = "That doesn't seem to be here anymore."
        self.actions["take " + item_to_remove.name.lower()] = "That doesn't seem to be here anymore."
        self.actions["take the " + item_to_remove.name.lower()] = "That doesn't seem to be here anymore."

    def battle(self):
        #setup
        print("A battle has started! You are fighting the enemies you found!")
        if random.randint(1,2) == 1:
            print("Your team goes first!")
            current_team = self.player.party.members
            opposing_team = self.enemies
        else:
            current_team = self.enemies
            opposing_team = self.player.party.members

        #the "you're actually fighting" loop
        while True:
            #prints the state of each team at the beginning of each 'round'
            if current_team[0] in self.enemies:
                print("Your team:")
                self.print_combat_team(opposing_team)
                print("Enemy team:")
                self.print_combat_team(current_team)
            else:
                print("Your team:")
                self.print_combat_team(current_team)
                print("Enemy team:")
                self.print_combat_team(opposing_team)

            #getting actions + carrying them out
            for current_fighter in current_team:
                #get their action
                if current_fighter == self.player: #could not get around this
                    result = current_fighter.fight(opposing_team)
                else:
                    result = current_fighter.fight()
                #if they're not attacking, they're done already
                if type(result) != tuple and type(result) != int:
                    continue
                #deal damage if they are attacking
                if type(result) != tuple:
                    current_opp = random.choice(opposing_team)
                else:
                    current_opp = opposing_team[result[1]]
                    result = result[0]
                print(f"{current_fighter.name} dealt {result} damage to {current_opp}!")
                if current_opp.is_hurt(result): #this method returns True if they have died
                    opposing_team.remove(current_opp)

            #win condition check
            if not opposing_team: #if one list is empty, that means tbhey have all died, and for now the only ones taking damage in a round are the opposite team
                if current_team[0] in self.player.party_members:
                    print("You won and defeated the enemy team! Good job!")
                    self.enemies = []
                    return
                else:
                    print("You lost. The enemy team defeated you.")
                    #you're all dead, but you don't die bcus i didn't make that. u and ur entire team are all immortal for now.
                    return
                
            #switch teams
            current_team , opposing_team = opposing_team , current_team #switches teams
            if current_team[0] in self.enemies:
                print("It is now the enemies' turn!")
            else:
                print("It is now your team's turn!")

    def unlock(self):
        if type(self.description[2]) == list:
            print(self.description[2][0])
            self.text += self.description[2][0]
            for (command,action) in self.description[1]:
                self.actions[command] = action

    def print_combat_team(self,team):
        for i in range(len(team)):
            print(f"{i+1}. {team[i].name}, a {team[i].type.name.lower()} with {team[i].current_hp} hp")


"""Environment sub-classes : can only be created by the Environment constructor,
mainly the same but may vary in which Items/Enemies/description texts they have access to."""

class Tundra(Environment):

    environment_type = "Tundra"
    description_choices = [("You are in a large expanse of snow. A wide, empty field of powder stretches out before you.","There seems to be flat stone beneath the snow when you brush your feet over it.",None),
                           ("You find yourself approaching a bumpy, icy terrain. It is a jagged minefield of frozen ice.",None,None),
                           ("Walking through snow, you come across a cave. You walk inside and continue on until you find something. It is a forgotten campfire and small discarded chest. The chest seems to be locked.","The campfire seems to have been put out a long time ago and the chest is plain, made of old-looking wood.",["The chest comes unlocked, and you find a few berries inside, but nothing else.",{}])]
    env_enemy_choices = Environment.enemy_choices # | can modify these two based on env.
    env_item_choices = Environment.item_choices   # v aka you might find a skull in a desert not anywhere else

    def __init__(self):

        super().__init__(Tundra)

class Desert(Environment):

    environment_type = "Desert"
    description_choices = [("You are in a desert, surrounded on all sides by sand and wind. You are near a ring of cacti.","The cacti look normal, and there is nothing near them.",None),
                           ("There is sand covering many dry grasses around your feet. You see sand dunes in the distance. There is a small painted basket on the ground, but it seems to be locked.",None,["Inside the basket, there is dried meat. There seems to be noone around, so you take it.",{}]),
                           ("You stand in rocky terrain, with sand blowing through the wind occasionally. There is a steep hill up ahead.","At the bottom of the hill, there is a vast expanse of sand.",None)]
    env_enemy_choices = Environment.enemy_choices
    env_item_choices = Environment.item_choices

    def __init__(self):

        super().__init__(Desert)

class Forest(Environment):

    environment_type = "Forest"
    description_choices = [("All around you, trees with crackling bark and wispy leaves stretch up to the sky. You pad around the carpet of dead leaves, but can't see much further past the trees.","You notice a hanging birdhouse on the highest branches of one of the trees. It is unreachable.",None),
                           ("You walk into a forest filled with brush, leaves, and vines. The greenery fills your view, and you notice many birds' nests and animal dens around you.",None,None),
                           ("You find yourelf walking around a forest of yellow, red, and green trees. Colorful flowers are spread across the ground.",None,None)]
    env_enemy_choices = Environment.enemy_choices
    env_item_choices = Environment.item_choices

    def __init__(self):

        super().__init__(Forest)

class Plains(Environment):

    environment_type = "Plains"
    description_choices = [("You walk into a deserted field of dirt. There is nothing around except for the sparse grass covering and numerous mole hills that litter the ground.",None,None),
                           ("You find a great plain of grass. The grass is as tall as your chest and grows even taller near what you discover is a stream cutting across the area.",None,None),
                           ("There is a field of flowers in front of you; the ground is completely covered in tiny multi-colored petals, and bees are buzzing around frantically.","There are many bees asleep inside the flowers.",None)]
    env_enemy_choices = Environment.enemy_choices
    env_item_choices = Environment.item_choices

    def __init__(self):

        super().__init__(Plains)

class Town(Environment):
    """Towns are special and may also contain NPCs, which can join the Player's Party and journey with them."""

    environment_type = "Town"
    description_choices = [("You step into a bustling marketplace, full of colorful stalls and people advertising their juicy foods.",None,None),
                           ("You find youself relatively alone in an intersection of cobblestone streets with equally cobblestone buildings cramping you on either side.",None,None),
                           ("It seems to be a town square, with a large important-looking building at the back of an open courtyard filled with debating people and a fountain.",None,None)]
    env_enemy_choices = Environment.enemy_choices
    env_item_choices = Environment.item_choices

    def __init__(self):

        super().__init__(Town)
        self.NPC = None
        if random.randint(1,10) == 10:
            self.NPC = Character(self)
            self.text += f" A person named {self.NPC.name} is in the space with you."
            self.actions["person"] = self.NPC.talk
            self.actions[self.NPC.name.lower()] = self.NPC.talk
            self.actions[self.NPC.name.split()[0].lower()] = self.NPC.talk

    def check_NPC_name(self,party):
        """NPC names must be unique and checked against all other NPCs by an outsider, here the Environemnt (aka Town in this case) does that job."""
        if self.NPC.name in [char.name for char in party]:
            self.NPC.change_name()
        in_sentences = self.text.split(".")
        in_sentences[-1] = f" A person named {self.NPC.name} is in the space with you."
        self.text = ".".join(in_sentences)

    def add_NPC_to_party(self):
        """Adds the NPC stored in the environment to the player in the environment's party"""
        while True:
            if self.player.party.find_member(self.NPC.name):
                self.NPC.change_name()
            else:
                break
        self.player.party.add_member(self.NPC)
        self.NPC = None